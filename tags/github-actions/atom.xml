<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>Noos - Where Thought, Code, and Craft Converge - github-actions</title>
    <subtitle>Personal blog about programming, technology, and engineering insights. Topics include Rust, DevOps, Linux, and software craftsmanship.</subtitle>
    <link rel="self" type="application/atom+xml" href="https://noos.blog/tags/github-actions/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://noos.blog"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2025-10-30T00:00:00+00:00</updated>
    <id>https://noos.blog/tags/github-actions/atom.xml</id>
    <entry xml:lang="en">
        <title>Covers on Autopilot — Why I Let AI Paint the Edges</title>
        <published>2025-10-30T00:00:00+00:00</published>
        <updated>2025-10-30T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://noos.blog/posts/ai-covers-on-autopilot/"/>
        <id>https://noos.blog/posts/ai-covers-on-autopilot/</id>
        
        <content type="html" xml:base="https://noos.blog/posts/ai-covers-on-autopilot/">&lt;p&gt;There are jobs you can do by hand for years and never notice the drag. For me it was cover images. Each new post: open a design tool, stare at a blank canvas, export a PNG, wire it to the post. Not hard, just enough friction to make publishing feel heavier than it should.&lt;&#x2F;p&gt;
&lt;p&gt;This is a short note about shaving that yak with a tiny toolchain: a context‑aware prompt, an image model, and some guardrails in CI. No heroics—just removing a repeated decision so the writing flows.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;why-automate-covers&quot;&gt;Why automate covers&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Consistency: 1200×630 every time. No more odd crops in link unfurls.&lt;&#x2F;li&gt;
&lt;li&gt;Momentum: publishing shouldn’t wait for “design time”.&lt;&#x2F;li&gt;
&lt;li&gt;Style: light background, a single accent, abstract shapes. Enough personality, zero fuss.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Over time the manual step was turning into a speed bump. That was the whole motivation.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-bumps-along-the-road-the-important-part&quot;&gt;The bumps along the road (the important part)&lt;&#x2F;h2&gt;
&lt;p&gt;I didn’t get it right on the first try. Here are the lessons that actually mattered.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Model and limits&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;At first I used Stable Horde for SDXL. It’s great and free, but CI doesn’t love queues. I kept seeing 400&#x2F;429s in the logs (invalid payload or rate‑limited). Switched to Replicate with an API token; still got rate limits sometimes, but at least the errors were predictable.&lt;&#x2F;p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Exact sizing&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;SDXL likes multiples of 64. I request 1024×576, then downscale to 1200×630 with Sharp. Crisp edges, correct aspect for social cards.&lt;&#x2F;p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;Slugs vs. filenames&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;My fallback logic assumed &lt;code&gt;page.slug&lt;&#x2F;code&gt; exactly matched the filename. It didn’t—some posts derive the slug from the permalink. I fixed the template to compute &lt;code&gt;slug-from-permalink&lt;&#x2F;code&gt; and look for &lt;code&gt;&#x2F;images&#x2F;covers&#x2F;{slug}.png&lt;&#x2F;code&gt;. Simple, but that bug cost the most time.&lt;&#x2F;p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;“Why is it regenerating?”&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;CI starts from a clean checkout. If covers aren’t in Git, they disappear each run. I added a cache step that restores &lt;code&gt;static&#x2F;images&#x2F;covers&lt;&#x2F;code&gt; keyed to &lt;code&gt;content&#x2F;posts&#x2F;**&#x2F;*.md&lt;&#x2F;code&gt;. Now the generator truly skips when a PNG already exists.&lt;&#x2F;p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;Context in prompts&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Pure tags produced vague images. I added a little context: title + ~240 chars of summary (description if present, otherwise a clean slice of the body). Still abstract, just more grounded.&lt;&#x2F;p&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;One‑time resets&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Sometimes you do want a full refresh. There’s a manual “Run workflow” input (&lt;code&gt;force_regenerate=true&lt;&#x2F;code&gt;) that bypasses the “file exists” check once. Good for style changes or a model upgrade.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;how-we-decided-on-ai-at-all&quot;&gt;How we decided on AI at all&lt;&#x2F;h2&gt;
&lt;p&gt;I tried three options in order:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Hand‑made banners (historically): high quality, low velocity.&lt;&#x2F;li&gt;
&lt;li&gt;Programmatic shapes: reliable, but too repetitive.&lt;&#x2F;li&gt;
&lt;li&gt;AI with guardrails: abstract, brand‑aware, hands‑off once it’s set.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The third option hit the balance. The prompt constrains style; the model supplies variation. It’s not “art direction”, but it serves the post—and that’s the only job here.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-pipeline-nuts-and-bolts&quot;&gt;The pipeline (nuts and bolts)&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Script: &lt;code&gt;scripts&#x2F;generate-ai-covers.mjs&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Scans &lt;code&gt;content&#x2F;posts&#x2F;*.md&lt;&#x2F;code&gt;, pulls &lt;code&gt;tags&lt;&#x2F;code&gt;, &lt;code&gt;title&lt;&#x2F;code&gt;, and a short summary.&lt;&#x2F;li&gt;
&lt;li&gt;Prompt (simplified):
&lt;blockquote&gt;
&lt;p&gt;Abstract, minimal illustration. Tags: {tags}. Title: {title}. Context: {summary}. Vector‑like, clean geometric shapes, high contrast, brand accent #d64a48 on #f6f7f4. No text.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Calls Replicate SDXL (model version from a secret), requests 1024×576, saves 1200×630 as &lt;code&gt;static&#x2F;images&#x2F;covers&#x2F;{slug}.png&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Skips generation if the PNG already exists (unless &lt;code&gt;FORCE_REGENERATE_COVERS=1&lt;&#x2F;code&gt;).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Template: &lt;code&gt;themes&#x2F;radion&#x2F;templates&#x2F;page.html&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;If a post doesn’t specify a cover, it tries &lt;code&gt;&#x2F;images&#x2F;covers&#x2F;{slug-from-permalink}.png&lt;&#x2F;code&gt; and hides the figure if missing.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;CI: &lt;code&gt;.github&#x2F;workflows&#x2F;deploy.yml&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Restores a covers cache before generation; saves it after.&lt;&#x2F;li&gt;
&lt;li&gt;Optional manual input &lt;code&gt;force_regenerate&lt;&#x2F;code&gt; for a one‑time refresh.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;what-github-actions-brings&quot;&gt;What GitHub Actions brings&lt;&#x2F;h2&gt;
&lt;p&gt;The boring kind of power: reliability.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Every run restores the previous covers, generates only what’s missing, and embeds without a front‑matter tweak.&lt;&#x2F;li&gt;
&lt;li&gt;When rate‑limited, the post still publishes—missing images pick up on the next run.&lt;&#x2F;li&gt;
&lt;li&gt;A small verification stage lists the covers in &lt;code&gt;public&#x2F;images&#x2F;covers&lt;&#x2F;code&gt; and checks that posts actually reference them.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;closing-the-loop&quot;&gt;Closing the loop&lt;&#x2F;h2&gt;
&lt;p&gt;This wasn’t about making the site “AI‑powered”. It was about removing a tiny friction point that kept breaking the flow. The rule of thumb I keep coming back to: automate anything that steals attention from writing. Covers were stealing attention. Now they aren’t.&lt;&#x2F;p&gt;
&lt;p&gt;And if the art ever needs a new feel? I flip the model or tweak the prompt, hit “Run workflow”, and let the pipeline repaint the edges while I get back to words.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>GitHub Actions: When Automation Meets Reality</title>
        <published>2025-10-19T00:00:00+00:00</published>
        <updated>2025-10-19T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://noos.blog/posts/github-actions-when-automation-meets-reality/"/>
        <id>https://noos.blog/posts/github-actions-when-automation-meets-reality/</id>
        
        <content type="html" xml:base="https://noos.blog/posts/github-actions-when-automation-meets-reality/">&lt;p&gt;When you first set up GitHub Actions for a project, it feels like magic. Push your code, and the CI&#x2F;CD pipeline takes care of everything—building, testing, deploying. But sometimes, the magic breaks. And when it does, you learn things you never expected to learn.&lt;&#x2F;p&gt;
&lt;p&gt;I recently went through a journey with GitHub Actions that taught me a lot about the gap between &quot;this should work&quot; and &quot;this actually works.&quot; Here&#x27;s what I learned, without exposing too many project details.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;background-building-with-zola&quot;&gt;Background: Building with Zola&lt;&#x2F;h2&gt;
&lt;p&gt;For context, this blog is built using &lt;a href=&quot;https:&#x2F;&#x2F;www.getzola.org&#x2F;&quot;&gt;Zola&lt;&#x2F;a&gt;, a static site generator written in Rust. Zola takes Markdown files and templates, processes them, and outputs a static HTML site. It&#x27;s fast, simple, and doesn&#x27;t require a runtime—just compile your site and serve the static files.&lt;&#x2F;p&gt;
&lt;p&gt;The deployment process is straightforward:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Write content in Markdown&lt;&#x2F;li&gt;
&lt;li&gt;Run &lt;code&gt;zola build&lt;&#x2F;code&gt; to generate static HTML&lt;&#x2F;li&gt;
&lt;li&gt;Deploy the generated files to a hosting service&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;This makes Zola an ideal candidate for GitHub Pages: you build once, deploy the static files, and GitHub Pages serves them. The challenge comes when you want to automate this process with GitHub Actions.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-promise-of-automation&quot;&gt;The Promise of Automation&lt;&#x2F;h2&gt;
&lt;p&gt;GitHub Actions promises a lot:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Automatic builds on every push&lt;&#x2F;li&gt;
&lt;li&gt;Consistent deployment environments&lt;&#x2F;li&gt;
&lt;li&gt;Less manual work, fewer human errors&lt;&#x2F;li&gt;
&lt;li&gt;Integration with GitHub Pages for static sites&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The setup looks straightforward:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Create a &lt;code&gt;.github&#x2F;workflows&#x2F;deploy.yml&lt;&#x2F;code&gt; file&lt;&#x2F;li&gt;
&lt;li&gt;Define your build steps&lt;&#x2F;li&gt;
&lt;li&gt;Push and watch it work&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;But reality has a way of complicating things.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;issue-1-the-submodule-problem&quot;&gt;Issue #1: The Submodule Problem&lt;&#x2F;h2&gt;
&lt;p&gt;One of the first issues I encountered was related to git submodules. If your project includes external dependencies managed as submodules, GitHub Actions needs explicit configuration to handle them.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;The Error:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;Error: fatal: No url found for submodule path &amp;#39;themes&#x2F;radion&amp;#39; in .gitmodules
&lt;&#x2F;span&gt;&lt;span&gt;Error: The process &amp;#39;&#x2F;usr&#x2F;bin&#x2F;git&amp;#39; failed with exit code 128
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;The Root Cause:&lt;&#x2F;strong&gt;
GitHub Actions tries to fetch submodules by default, but if your &lt;code&gt;.gitmodules&lt;&#x2F;code&gt; file is missing or incomplete, or if the submodule path exists but isn&#x27;t properly configured, the build fails.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;The Solution:&lt;&#x2F;strong&gt;
If you&#x27;re not actually using submodules (maybe you copied files directly), you have two options:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Remove the submodule completely:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; rm&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --cached&lt;&#x2F;span&gt;&lt;span&gt; themes&#x2F;radion
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rm -rf&lt;&#x2F;span&gt;&lt;span&gt; themes&#x2F;radion&#x2F;.git
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; add themes&#x2F;radion
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; commit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -m &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Convert submodule to regular directory&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Configure GitHub Actions to skip submodules:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;uses&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;actions&#x2F;checkout@v4
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;with&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;submodules&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;false
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;I went with option 1 because I wasn&#x27;t actually using submodules—I had copied the theme files directly into the repository. The submodule reference was leftover from an earlier setup.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;issue-2-branch-confusion&quot;&gt;Issue #2: Branch Confusion&lt;&#x2F;h2&gt;
&lt;p&gt;GitHub Pages supports two deployment methods:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GitHub Actions:&lt;&#x2F;strong&gt; Build your site using a workflow&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Branch-based:&lt;&#x2F;strong&gt; Serve files directly from a branch (like &lt;code&gt;gh-pages&lt;&#x2F;code&gt;)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;I started with GitHub Actions, but ran into issues. The build kept failing, and debugging CI&#x2F;CD pipelines can be frustrating—you push, wait, check logs, repeat.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;The Revelation:&lt;&#x2F;strong&gt;
Sometimes, manual deployment to a &lt;code&gt;gh-pages&lt;&#x2F;code&gt; branch is simpler and more reliable. You get:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Full control over when and how you deploy&lt;&#x2F;li&gt;
&lt;li&gt;Ability to test locally before deploying&lt;&#x2F;li&gt;
&lt;li&gt;No hidden automation surprises&lt;&#x2F;li&gt;
&lt;li&gt;Easier debugging (you can inspect the built files directly)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;The Manual Approach:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# Build locally
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;zola&lt;&#x2F;span&gt;&lt;span&gt; build&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --output-dir&lt;&#x2F;span&gt;&lt;span&gt; public&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --force
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# Deploy to gh-pages branch
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; checkout&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -B&lt;&#x2F;span&gt;&lt;span&gt; gh-pages
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsync -av --delete --exclude&lt;&#x2F;span&gt;&lt;span&gt;=&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.git&#x2F;&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; public&#x2F; .
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; add&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -A
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; commit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -m &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Publish: &lt;&#x2F;span&gt;&lt;span&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;date&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt; +&lt;&#x2F;span&gt;&lt;span&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Y&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;m&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;d&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; push&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -f&lt;&#x2F;span&gt;&lt;span&gt; origin gh-pages
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt; checkout main
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Is this less &quot;modern&quot;? Maybe. But it&#x27;s transparent, predictable, and gives you control when you need it.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;update-automation-wins-after-all&quot;&gt;Update: Automation Wins After All&lt;&#x2F;h2&gt;
&lt;p&gt;After writing the initial version of this post, I realized something: maintaining two branches manually was becoming a burden. The workflow was reliable, but it required:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Remembering to switch branches&lt;&#x2F;li&gt;
&lt;li&gt;Running build commands&lt;&#x2F;li&gt;
&lt;li&gt;Manually syncing files&lt;&#x2F;li&gt;
&lt;li&gt;Switching back to main&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;The Solution:&lt;&#x2F;strong&gt;
I revisited GitHub Actions, but this time with a clear understanding of the issues:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Configured submodules properly (&lt;code&gt;submodules: false&lt;&#x2F;code&gt; since we don&#x27;t use them)&lt;&#x2F;li&gt;
&lt;li&gt;Used a reliable deployment action (&lt;code&gt;peaceiris&#x2F;actions-gh-pages&lt;&#x2F;code&gt;)&lt;&#x2F;li&gt;
&lt;li&gt;Set up the workflow to trigger on push to &lt;code&gt;main&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;The Result:&lt;&#x2F;strong&gt;
Now I just push to &lt;code&gt;main&lt;&#x2F;code&gt;, and GitHub Actions handles everything:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Builds the site automatically&lt;&#x2F;li&gt;
&lt;li&gt;Deploys to &lt;code&gt;gh-pages&lt;&#x2F;code&gt; branch&lt;&#x2F;li&gt;
&lt;li&gt;Updates GitHub Pages&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;What Changed:&lt;&#x2F;strong&gt;
The key was understanding the submodule issue first. Once that was resolved, the automation became reliable. The workflow is simple and transparent—I can see exactly what&#x27;s happening in the Actions tab.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;The Lesson:&lt;&#x2F;strong&gt;
Sometimes automation &lt;em&gt;does&lt;&#x2F;em&gt; make sense. The difference between my first attempt and my second attempt was:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Understanding the root causes (submodules, branch setup)&lt;&#x2F;li&gt;
&lt;li&gt;Using proven, maintained actions&lt;&#x2F;li&gt;
&lt;li&gt;Starting simple and adding complexity only when needed&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The manual approach taught me what was happening under the hood. That knowledge made the automation reliable.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;issue-3-missing-scripts-and-assets&quot;&gt;Issue #3: Missing Scripts and Assets&lt;&#x2F;h2&gt;
&lt;p&gt;When deploying to GitHub Pages, you need to ensure all your assets are included. This might seem obvious, but it&#x27;s easy to miss.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;The Problem:&lt;&#x2F;strong&gt;
Your site builds locally, but when deployed, certain features don&#x27;t work—like a theme toggle button that does nothing, or search functionality that&#x27;s broken.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;The Cause:&lt;&#x2F;strong&gt;
JavaScript files weren&#x27;t being included in the HTML. The build process generated the files, but the HTML templates weren&#x27;t referencing them correctly, or the script tags were missing entirely.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;The Fix:&lt;&#x2F;strong&gt;
Manually verify that all necessary scripts are loaded:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Check your HTML templates&lt;&#x2F;li&gt;
&lt;li&gt;Ensure script tags are in the correct order&lt;&#x2F;li&gt;
&lt;li&gt;Verify paths are correct (especially for GitHub Pages subdirectory paths)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Sometimes, the simplest solution is to open the generated HTML and check what&#x27;s actually there.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;issue-4-the-abstraction-trap&quot;&gt;Issue #4: The Abstraction Trap&lt;&#x2F;h2&gt;
&lt;p&gt;Here&#x27;s the thing about automation: when it works, it&#x27;s great. When it doesn&#x27;t, you&#x27;re debugging an abstraction layer you may not fully understand.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;The Pattern:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Something breaks&lt;&#x2F;li&gt;
&lt;li&gt;You check GitHub Actions logs&lt;&#x2F;li&gt;
&lt;li&gt;You see an error message&lt;&#x2F;li&gt;
&lt;li&gt;You make a change&lt;&#x2F;li&gt;
&lt;li&gt;You push and wait&lt;&#x2F;li&gt;
&lt;li&gt;Repeat&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;This cycle can be slow, especially if your builds take a few minutes each time.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;The Alternative:&lt;&#x2F;strong&gt;
With manual deployment:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Build locally (instant feedback)&lt;&#x2F;li&gt;
&lt;li&gt;Test locally&lt;&#x2F;li&gt;
&lt;li&gt;Deploy when ready&lt;&#x2F;li&gt;
&lt;li&gt;Inspect the deployed files directly&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;The feedback loop is faster, and you understand every step.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;issue-5-github-pages-source-branch-mismatch&quot;&gt;Issue #5: GitHub Pages Source Branch Mismatch&lt;&#x2F;h2&gt;
&lt;p&gt;Even after getting the deployment pipeline working, some issues only surfaced when viewing the site in production. These weren&#x27;t build failures—they were configuration problems.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-github-pages-source-branch-mismatch&quot;&gt;The GitHub Pages Source Branch Mismatch&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;The Symptom:&lt;&#x2F;strong&gt;
After deploying fixes, the blog post updates weren&#x27;t appearing on the live site. The build succeeded, GitHub Actions showed successful deployment, but visiting the site showed old content.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;The Root Cause:&lt;&#x2F;strong&gt;
GitHub Pages has two deployment methods:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;GitHub Actions&lt;&#x2F;strong&gt; - Pages builds from Actions workflow output&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Branch-based&lt;&#x2F;strong&gt; - Pages serves files directly from a branch (like &lt;code&gt;gh-pages&lt;&#x2F;code&gt;)&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;The problem was a configuration mismatch: GitHub Pages was set to use &quot;GitHub Actions&quot; as the source, but our workflow was deploying to the &lt;code&gt;gh-pages&lt;&#x2F;code&gt; branch. GitHub Pages was trying to serve from the Actions output, not the branch we were deploying to.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;The Fix:&lt;&#x2F;strong&gt;
Changed GitHub Pages source back to &lt;code&gt;gh-pages&lt;&#x2F;code&gt; branch in repository settings:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Go to repository Settings → Pages&lt;&#x2F;li&gt;
&lt;li&gt;Under &quot;Source&quot;, select &quot;Deploy from a branch&quot;&lt;&#x2F;li&gt;
&lt;li&gt;Choose &lt;code&gt;gh-pages&lt;&#x2F;code&gt; branch and &lt;code&gt;&#x2F; (root)&lt;&#x2F;code&gt; folder&lt;&#x2F;li&gt;
&lt;li&gt;Save&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;Why This Happened:&lt;&#x2F;strong&gt;
When you first set up GitHub Actions, GitHub Pages might automatically switch to &quot;GitHub Actions&quot; mode. If your workflow deploys to &lt;code&gt;gh-pages&lt;&#x2F;code&gt; branch (which is common), you need to ensure the Pages source matches where you&#x27;re deploying.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;The Lesson:&lt;&#x2F;strong&gt;
Always verify that your GitHub Pages source matches your deployment target. If your Actions workflow deploys to &lt;code&gt;gh-pages&lt;&#x2F;code&gt;, make sure Pages is configured to serve from that branch. Configuration mismatches can cause silent failures where everything appears to work but content doesn&#x27;t update.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;testing-across-browsers&quot;&gt;Testing Across Browsers&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;The Problem:&lt;&#x2F;strong&gt;
Different browsers cache differently. Chrome might show updated content while Firefox shows old content, or vice versa. However, in this case, the issue wasn&#x27;t browser caching—it was a configuration mismatch.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;The Solution:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Always verify GitHub Pages source matches your deployment method&lt;&#x2F;li&gt;
&lt;li&gt;Check GitHub Actions logs to confirm deployment succeeded&lt;&#x2F;li&gt;
&lt;li&gt;Wait 2-5 minutes for GitHub Pages to rebuild after deployment&lt;&#x2F;li&gt;
&lt;li&gt;Use hard refresh (Cmd+Shift+R &#x2F; Ctrl+Shift+R) when testing&lt;&#x2F;li&gt;
&lt;li&gt;Test in multiple browsers to rule out caching issues&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;What I Learned:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;GitHub Pages configuration must match your deployment method&lt;&#x2F;li&gt;
&lt;li&gt;Always verify the deployment target matches the Pages source&lt;&#x2F;li&gt;
&lt;li&gt;Testing locally doesn&#x27;t catch configuration mismatches&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;when-to-use-github-actions&quot;&gt;When to Use GitHub Actions&lt;&#x2F;h2&gt;
&lt;p&gt;Don&#x27;t get me wrong—GitHub Actions is powerful and useful. Use it when:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;You need automated testing on every commit&lt;&#x2F;li&gt;
&lt;li&gt;You want consistent build environments&lt;&#x2F;li&gt;
&lt;li&gt;Multiple people are deploying&lt;&#x2F;li&gt;
&lt;li&gt;You need to run expensive operations (like building large projects)&lt;&#x2F;li&gt;
&lt;li&gt;You want to enforce code quality checks&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;But consider manual deployment when:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Your build process is simple&lt;&#x2F;li&gt;
&lt;li&gt;You want full control&lt;&#x2F;li&gt;
&lt;li&gt;You&#x27;re deploying infrequently&lt;&#x2F;li&gt;
&lt;li&gt;You want to understand every step&lt;&#x2F;li&gt;
&lt;li&gt;Debugging automation is slowing you down&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;lessons-learned&quot;&gt;Lessons Learned&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Understand your dependencies:&lt;&#x2F;strong&gt; Know whether you&#x27;re using submodules, npm packages, or other external resources. This affects your CI&#x2F;CD setup.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Test locally first:&lt;&#x2F;strong&gt; Always build and test your site locally before relying on automation. Automation catches mistakes, but you should catch them first.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Keep it simple:&lt;&#x2F;strong&gt; If automation adds complexity without clear benefits, consider if manual processes might be better for your use case.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Inspect the output:&lt;&#x2F;strong&gt; When something doesn&#x27;t work, look at the actual generated files. HTML errors, missing assets, and broken links are often visible in the source.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Verify GitHub Pages configuration matches deployment:&lt;&#x2F;strong&gt; If your Actions workflow deploys to &lt;code&gt;gh-pages&lt;&#x2F;code&gt; branch, ensure GitHub Pages source is set to that branch. Configuration mismatches cause silent failures.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Test across browsers:&lt;&#x2F;strong&gt; Different browsers cache differently. Always test in multiple browsers after deployment, and use hard refresh when debugging.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Document your process:&lt;&#x2F;strong&gt; Whether you use automation or manual deployment, document it. Future you (and your team) will thank you.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;GitHub Actions is a powerful tool, but it&#x27;s not always the right tool—at least not immediately. My journey started with frustration, moved to manual control, and ended with successful automation.&lt;&#x2F;p&gt;
&lt;p&gt;The manual approach wasn&#x27;t wasted effort. It taught me:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;What was happening under the hood&lt;&#x2F;li&gt;
&lt;li&gt;How the build process worked&lt;&#x2F;li&gt;
&lt;li&gt;What could go wrong and why&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;That knowledge made the automation reliable. When I returned to GitHub Actions, I understood the root causes and could configure it correctly.&lt;&#x2F;p&gt;
&lt;p&gt;The key is to choose the approach that fits your project, your team, and your workflow. Sometimes that means starting manually to understand the process, then automating once you know what you&#x27;re automating.&lt;&#x2F;p&gt;
&lt;p&gt;At the end of the day, the goal is to deploy reliably and efficiently. Whether that&#x27;s through GitHub Actions, manual commands, or a hybrid approach, what matters is that it works for you—and that you understand why it works.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h3 id=&quot;further-reading&quot;&gt;Further Reading&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.github.com&#x2F;en&#x2F;actions&quot;&gt;GitHub Actions Documentation&lt;&#x2F;a&gt; – Official documentation&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.github.com&#x2F;en&#x2F;pages&quot;&gt;GitHub Pages Deployment&lt;&#x2F;a&gt; – Deployment strategies&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;git-scm.com&#x2F;book&#x2F;en&#x2F;v2&#x2F;Git-Tools-Submodules&quot;&gt;Managing Git Submodules&lt;&#x2F;a&gt; – Git submodule basics&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
        
    </entry>
</feed>
